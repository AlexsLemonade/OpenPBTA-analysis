---
title: "Introduction to svcnvplys"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to svcnvplys}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```
  
```{r include=FALSE}
require(taRifx)
require(data.table)
require(tidyr)
require(circlize)
require(GenomicRanges)
require(D3GB)
```

`svncvplus` is an R package designed for downstream analyses of DNA copy number variations (CNV) and other structural variants (SV).
CNV data can be derived from genotyping and CGH arrays, as well as next generation sequencing; different segmentation algorithms are used to obtain dosage variations (duplications and deletions) across the genome. Alternatively SV calls can be inferred from discordantly aligned reads from whole genome sequencing (WGS) using different algorithms (e.g [manta](https://github.com/Illumina/manta), [lumpy](https://github.com/arq5x/lumpy-sv), etc). SV calls provide linkage information from discordantly aligned reads and read pairs, allowing the discovery of chromosomal translocations and variants that do not necesarily involve dosage change, such as inversions and insertions.  Segmentation CNVs and alignment based SV calls produce orthogonal as well as complementary results. The integration of both data types can by highly informative to understand the somatic alterations driving many cancers and is essential to characterize complex chromosomal alterations such as chromothripsis and chromoplexy.
In summary, `svcnvplus` is a toolkit for the integration of SV datasets, visualization and characterization of complex somatic SVs.

## Index:

* [Input data](#input-data)
* [Validate data types](#validate-data-types)
    * [Validate segmentation data format](#validate-segmentation-data-format)
    * [Validate structural variant data format](#validate-structural-variant-data-format)
* [CNV analysys and visualization](#cnv-analysys-and-visualization)
    * [CNV frequency plot](#cnv-frequency-plot)
    * [Gene-level CNV](#gene-level-cnv)
    * [Percent genome change](#percent-genome-change)
* [Co-localization of breakpoints](#co\-localization-of-breakpoints)
* [Breakpoint burden](#breakpoint-burden)
* [Identification of shattered regions](#identification-of-shattered-regions)
    * [Chromosome shattering using segmentation data only](#chromosome-shattering-using-segmentation-data-only)
    * [Chromosome shattering using segmentation and SV data](#chromosome-shattering-using-segmentation-and-sv-data)
* [Recurrently shattered regions](#recurrently-shattered-regions)
    * [Recurrently shattered regions plot](#recurrently-shattered-regions-plot)
* [Recurrently altered genes](#recurrently-altered-genes)
    * [Amplifications and deep deletions](amplifications-and-deep-deletions)
    * [Recurrently altered genes using CNV breakpoints](#recurrently-altered-genes-using-cnv-breakpoints)
    * [Recurrently altered genes using SV breakpoints](#recurrently-altered-genes-using-sv-breakpoints)


## Input data

Two data types are allowed:
    * CNV segmentation data
    * SV calls

To explore the basic functionalities of svcnvplus, several data.frames are included `svcnvplus::segdat_lung_ccle` and `svcnvplus::svdat_lung_ccle`. This data.frames contain information about CNV segments and structural variants respectively for lung cancer derived cell lines. This data was obtained from <https://depmap.org/portal/download/>. Both data.frames are lazy loaded with `svcnvplus`

```{r message=FALSE}
library(svcnvplus)
dim(nbl_segdat)
head(nbl_segdat)

dim(nbl_svdat)
head(nbl_svdat)
```

## Validate data types

* `validate.seg()` check format for segmentation data.frame
* `validate.sv()` chrek format of a Structural variant data.frame

### Validate segmentation data format

Validate and format segmentation data.frame to be used by svcnvplus package toolkit

```{r}
segdf <- validate.seg(nbl_segdat)
head(segdf)
```


### Validate structural variant data format 

Validate and format structural variant data.frame to be used by svcnvplus package toolkit

```{r}
svdf <- validate.sv(nbl_svdat)
head(svdf)
```

## CNV analysys and visualization

### CNV frequency plot

Visualization of CNV frequencies across the genome 

```{r message=FALSE, echo = FALSE}
segdf_clean <- clean.cnv.artifact(segdf, verbose=FALSE,n.reps = 4)  # remove likely artifacts from segmentation data
```

```{r plot1,  fig.width=9, fig.height=4, fig.align='center', fig.cap = "Genome wide CNV frequencies", message=FALSE}
cnv_freq <- cnv.freq.plot(segdf)  # plot cnv frequencies
```

```{r message=FALSE}
head(cnv_freq$freqsum)  # data.frame contains every genomic bin 

```

### Gene level CNV

Generate a matrix with gene level CNVs from a segmentation file

```{r message=FALSE}
gene_cnv <- gene.cnv(segdf_clean,genome.v = "hg19",fill.gaps = TRUE,verbose=FALSE)
```
```{r}
dim(gene_cnv$cnvmat)
```


### Percent genome change

Returns per sample percentage of genome with CNV 

```{r message=FALSE}
pct_change <- pct.genome.changed(segdf)
```

## Co-localization of breakpoints

CNVs (duplications and deletions) are a subset of all structural variants; Both CNV segmentation profiles and structural variants derived from discordant alignments produce orthogonal calls for these genomic events. The function `match.variant.breaks` allows identifying common breakpoints called by both approaches.

```{r plot2,  fig.width=9, fig.height=5, fig.align='center', fig.cap = "Common breakpoints by sample",  message=FALSE}
common.breaks <- match.variant.breaks(segdf,svdf,maxgap=50000,low.cov = NULL,verbose=FALSE)

restab <- data.frame(common.breaks$restab)[order(common.breaks$restab$total.sv),]
m2 <- sprintf("%.1f",100*mean(restab$matched.sv/restab$total.sv))
barplot(rbind(restab$matched.sv,restab$total.sv - restab$matched.sv),
        border=NA,las=2,xlab="",horiz=FALSE,cex.main=.7,cex.names=.4, names=rownames(restab))
legend("top",paste("SV breaks matched by CNV breaks\n","Average = ",m2,"%",sep=""),bty='n')
grid(ny=NULL,nx=NA)
```

## Breakpoint burden

In addition to percent genome changes, we can measure the total burden of breakpoints derived from CNV segments and SV calls

```{r plot3, fig.width=5, fig.height=5, fig.align='center', fig.cap = "SV versus CNV breakpoint burden",  message=FALSE}
sv_breaks_df  <- sv.breaks(svdf)  # define breakpoints from SV data
sv_burden <- table(sv_breaks_df$sample)
seg_breaks_df  <- seg.breaks(segdf,fc.pct = 0.2,verbose=FALSE)  # define breakpoints from seg data based on certain CNV change cutoff
seg_burden <- table(seg_breaks_df$sample)
common_samples <- intersect(names(sv_burden),names(seg_burden))
dat <- cbind(sv_burden[common_samples],seg_burden[common_samples])
plot(dat,xlab="SV burden",ylab="CNV breakpoint burden")
legend("topright",paste("cor=",cor(dat)[1,2], sep=""))
```


## Identification of shattered regions

Complex chromosomal rearrangements such as chromothripsis and chromoplexy are widespread events in many cancers and may have important pathogenic roles. `svcnvplus` incorporates tools to map and visualize shattered regions across multiple samples.

We used LUNG cancer cell line profiles from the CCLE in order to illustrated these tools:

Validate segmentation and SV data.frames
```{r message=FALSE}
segdf <- validate.seg(segdat_lung_ccle)
svdf <- validate.sv(svdat_lung_ccle)
```

### Chromosome shattering using segmentation data only

The whole genome is binned into user defined `window.size` (Mb) and slided by `slide.size` (Mb) in order to identify regions with high CNV breakpoint density. Two cutoffs are considered for each genomic bin:\n
    * num.breaks = the minimum number of breakpoints
    * num.sd = the number of standard deviations above the average within a sample
In addition, we evaluate the interquantile average of the distance between breakpoints in a given region:\n
    * dist.iqm.cut (default = 150000 b)

```{r message=FALSE}
shatt_lung_cnv <- shattered.regions.cnv(segdf, fc.pct = 0.2, clean.brk = 4, window.size = 10,
                                        slide.size = 2,num.breaks = 8, num.sd = 5,  
                                        dist.iqm.cut = 150000,verbose=FALSE)

shatt_lung_cnv$regions.summary$A549_LUNG
```


### Chromosome shattering using segmentation and SV data

Analogously we can combine CNVs and SVs breakpoins to obtain a more robust evaluation of chromosome shattering (see `?shattered.regions`) 
In addition SVs provide linkage for each SV breakpoint pair which allow for an additional parametter:\n
    * interleaved.cut the minimun percentage (0-1) of interleaved SVs
    




```{r message=FALSE}
shatt_lung <- shattered.regions(segdf, svdf, fc.pct = 0.2,  min.num.probes = 5, clean.brk = 8,
                                window.size = 10,slide.size = 2, num.seg.breaks = 6, 
                                num.seg.sd = 5, num.sv.breaks = 6, num.sv.sd = 5, 
                                num.common.breaks = 3, num.common.sd = 0, interleaved.cut = 0.33,
                                dist.iqm.cut = 100000,verbose=FALSE)
shatt_lung$regions.summary$SCLC21H_LUNG
```

Circos plotting is available via [circlize](https://cran.r-project.org/web/packages/circlize/index.html) package wrapper function:

```{r plot4, fig.width=5, fig.height=5, fig.align='center', fig.cap = "Circos plot representing c LUNG cancer cell line with chromothripsis",  message=FALSE}
circ.chromo.plot(shatt_lung,sample.id = "SCLC21H_LUNG")
```

### Recurrently shattered regions

We evaluate the null hipothesis that shattered regions (genomic bins) may occour throughout the genome at random; To this end we first create an empirical null distribution based on the sample set we are studying. And compare with the observed distribution. This also allows to define an empirical FDR cutoff.

```{r message=FALSE}
fdr.test <- freq.p.test(shatt_lung_cnv$high.density.regions.hc, method="bonferroni", p.cut = 0.05)
```

### Recurrently shattered regions plot

We can visualize the aggregate map of shattered regions for all samples with `recurrent.regions.plot`

```{r plot5,  fig.width=9, fig.height=4, fig.align='center', fig.cap = "Recurrently shattered regions map", message=FALSE}
recurrent.regions.plot(shatt_lung_cnv, fdr = fdr.test$freq.cut)
```

And finally collect groups of samples with shattered chromosomes in recurrent regions as defined by a given fdr cutoff

```{r message=FALSE}
# obtain genomic bins within above the FDR cutoff
freq.matrix <- apply(shatt_lung_cnv$high.density.regions.hc,2,sum)
textRegions <- names(which(freq.matrix >= fdr.test$freq.cut))
hitRegions <- remove.factors((data.frame(do.call(rbind,strsplit(textRegions," ")))))
hitRegions[,2] <- as.numeric(hitRegions[,2])
hitRegions[,3] <- as.numeric(hitRegions[,3])
colnames(hitRegions) <- c("chr","start","end")
rownames(hitRegions) <-textRegions

# collapes contiguous bins into unique regions
bins2remove <- c()
for(i in 2:nrow(hitRegions)){ 
  if(hitRegions[i,"chr"] == hitRegions[i-1,"chr"] ){
    if(hitRegions[i,"start"] < (hitRegions[i-1,"end"])){
      hitRegions[i,"start"] <- hitRegions[i-1,"start"]
      bins2remove <- c(bins2remove,textRegions[i-1])
    }
  }
}
hitRegionsPost<- hitRegions[setdiff(rownames(hitRegions),bins2remove),]

require(GenomicRanges)
hitRegions_gr <- with(hitRegions, GRanges(chr, IRanges(start=start, end=end)))
hitRegionsPost_gr <- with(hitRegionsPost, GRanges(chr, IRanges(start=start, end=end)))
hits <-GenomicAlignments::findOverlaps(hitRegionsPost_gr,hitRegions_gr)

regList <- list()
for(i in unique(queryHits(hits))) regList[[paste(hitRegionsPost[i,],collapse=" ") ]] <- textRegions[subjectHits(hits)[which(queryHits(hits) == i)]]
# obtain the genomic bins with maximum number of samples
regListPeak <- lapply(regList, function(x) names(which(freq.matrix[x] == max(freq.matrix[x]))))
# collect samples with shattered region in the peaks 
regListPeakSamples <- lapply(regListPeak, function(x) names(which(apply(cbind(shatt_lung_cnv$high.density.regions.hc[,x]),1,sum) > 0)))
```

Beyond this point the user can test case/control hipothesys for chromosome shattering of specific genomic regions...

## Recurrently altered genes

### amplifications and deep deletions

### Recurrently altered genes using CNV breakpoints

Instead of focusing on high-level dosage changes, we evaluate whether CNV break ends overlap with known genes or upstream regions. 

```{r message=FALSE}

results_cnv <- cnv.gene.breaks(nbl_segdat, fc.pct = 0.2, genome.v="hg19",clean.brk = 8,upstr = 50000,verbose=FALSE)
```

We can obtain a ranking of altered genes by breakpoints overlapping their transcriptions start and end...
```{r plot6,  fig.width=9, fig.height=4, fig.align='center', fig.cap = "Recurrently altered genes with overlapping CNV breakpoints", message=FALSE}
barplot(sort(unlist(lapply(results_cnv$geneSamples,length)),decreasing=T)[1:20],las=2)
```

... or upstream (50Kb)
```{r plot7,  fig.width=9, fig.height=4, fig.align='center', fig.cap = "Recurrently altered genes with overlapping CNV breakpoints", message=FALSE}
barplot(sort(unlist(lapply(results_cnv$upstreamSamples,length)),decreasing=T)[1:20],las=2)
```

### Recurrently altered genes using SV breakpoints


results_cnv$

