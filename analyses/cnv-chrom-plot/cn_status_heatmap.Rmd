---
title: "CNV GISTIC Plots"
output:   
  html_notebook: 
    toc: true
    toc_float: true
author: Candace Savonen for ALSF - CCDL
date: 2020
---

### Usage

This notebook can be run via the command line from the top directory of the 
repository as follows:

```
Rscript -e "rmarkdown::render('analyses/cnv-chrom-plot/gistic_plot.Rmd', 
                              clean = TRUE)"
```

### Set Up

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`
```

### Directories and Files

```{r}
# Path to input directory
input_dir <- file.path("..", "..", "data")
scratch_dir <- file.path("..", "..", "scratch")

# Path to output directory
plots_dir <- "plots"

# Create the plots_dir if it does not exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}
```

Custom function for calculating number of base pairs of coverage for each bin. 

```{r}
bp_per_bin <- function(bins, status_ranges) {
    # Find the portions of each segment that overlap with each bin. 
    bin_overlaps <- GenomicRanges::pintersect(
      IRanges::findOverlapPairs(bins, 
                                 status_ranges)
      )
  
    # Which segs are a part of which bins?
    bin_indices <- GenomicRanges::findOverlaps(bin_overlaps, 
                                                status_ranges)
  
    # Get the sum of the length of all excluded regions for each bin.
    bp_per_bin <- tapply(
      bin_overlaps@ranges@width[bin_indices@to], # Get length of each sequence
      bin_indices@from, # Index of which bin it overlaps
      sum
    ) # Add up per bin
    
    data.frame(bin = names(bp_per_bin),
               bp_per_bin)
  }
```

### Read in data 

```{r}
# Read in metadata
metadata <-
  readr::read_tsv(file.path(input_dir, "pbta-histologies.tsv"))
```

Read in and set up the seg consensus file. 

```{r}
# Read in the segment copy number data
seg_data <- data.table::fread(file.path(
  input_dir, 
  "pbta-cnv-consensus.seg.gz"),
  data.table = FALSE
) 
```

Read in the chromosomal sizes so we can fill in neutral spaces. 
(This has nothing to do with Strelka, but it just so happens this is a file with the sizes 
of the chromosomes in this genome build, hg38).

```{r}
chr_sizes <- readr::read_tsv(file.path(input_dir, "WGS.hg38.strelka2.unpadded.bed"),
  col_names = c("chrom", "start", "end")
) %>%
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom),
    levels = c(1:22, "X", "Y", "M")
  )) %>%
  # Remove sex chromosomes
  dplyr::filter(!(chrom %in% c("X", "Y", "M")))


# Make chromosome size named vector for Heatmap annotation
chr_sizes_vector <- chr_sizes$end
names(chr_sizes_vector) <- chr_sizes$chrom
```

Read in uncallable regions file. 
Regions that were not able to be accurately called will need to be color coded gray. 

```{r}
uncallable_bed <- readr::read_tsv(file.path("..", 
                                            "copy_number_consensus_call", 
                                            "ref", 
                                            "cnv_excluded_regions.bed"
                                            ),
  col_names = c("chrom", "start", "end")
) %>%
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom),
    levels = c(1:22, "X", "Y")
  )) %>%
  dplyr::filter(
    !is.na(chrom),
    # Drop sex chromosomes
    !(chrom %in% c("X", "Y", "M"))
  )
```

## Set up the seg consensus data variables

```{r}
seg_data <- seg_data %>%
  # Join the histology column to this data
  dplyr::inner_join(dplyr::select(
    metadata,
    "Kids_First_Biospecimen_ID",
    "short_histology", 
    "germline_sex_estimate", 
    "tumor_ploidy"
  ),
  by = c("ID" = "Kids_First_Biospecimen_ID")
  ) %>% 
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom), 
                               levels = c(1:22, "X", "Y"))) %>% 
  # Recode the copy number status based on ploidy
  dplyr::mutate(status = case_when(
    # when the copy number is less than inferred ploidy, mark this as a loss
    copy.num < tumor_ploidy ~ "loss",
    # if copy number is higher than ploidy, mark as a gain
    copy.num > tumor_ploidy ~ "gain",
    copy.num == tumor_ploidy ~ "neutral"
  )) %>%
  # Remove sex chromosomes
  dplyr::filter(!(chrom %in% c("X", "Y", "M")))
```

## Format each data item into GenomicRanges objects

Set up seg data as GenomicRanges. 

```{r}
seg_ranges <- GenomicRanges::GRanges(
  seqnames = seg_data$chrom,
  ranges = IRanges::IRanges(
    start = seg_data$loc.start,
    end = seg_data$loc.end
  ),
  status = seg_data$status, 
  histology = seg_data$short_histology, 
  biospecimen = seg_data$ID
)

```

Set up uncallable regions as GenomicRanges. 

```{r}
uncallable_ranges <- GenomicRanges::GRanges(
  seqnames = uncallable_bed$chrom,
  ranges = IRanges::IRanges(
    start = uncallable_bed$start,
    end = uncallable_bed$end
  )
)
```

## Bin the genome

```{r}
# Find which regions of the chromosome are uncallable
bins <- GenomicRanges::tileGenome(chr_sizes_vector, 
                                  tilewidth = 1e6)
bins <- unlist(bins)
```

## Combine the data objects into one

```{r}
sample_id <- seg_ranges$biospecimen[1]

call_bin_status <- function(sample_id,
                            seg_ranges, 
                            perc_delta_threshold = .05) {
  
  # Extract the ranges for this sample
  sample_seg_ranges <- seg_ranges[which(seg_ranges$biospecimen == sample_id)]
  
  # Split ranges into their respective statuses
  gain_ranges <- sample_seg_ranges[sample_seg_ranges$status == "gain"]
  loss_ranges <- sample_seg_ranges[sample_seg_ranges$status == "loss"]
  neutral_ranges <- sample_seg_ranges[sample_seg_ranges$status == "neutral"]

  # Calculate length of each type of status per bin
  gain_per_bin <- bp_per_bin(bins, gain_ranges)
  loss_per_bin <- bp_per_bin(bins, loss_ranges)
  neutral_per_bin <- bp_per_bin(bins, neutral_ranges)

  # Format this data into one data.frame where each row is a bin
  bin_bp_status <- data.frame(bin = factor(1:length(bins)), 
                              # Keep bin width
                              bin_width = bins@ranges@width) %>%
  # Join gains coverage data
  dplyr::left_join(gain_per_bin, 
                   by = "bin") %>% 
  # Join loss coverage data
  dplyr::left_join(loss_per_bin, 
                   by = "bin",
                   suffix = c(".gain", ".loss")) %>% 
  # Join neutral coverage data
  dplyr::left_join(neutral_per_bin, 
                   by = "bin") %>% 
  # If there is an NA, at this point we can assume it means 0
  dplyr::mutate_at(dplyr::vars(
    dplyr::starts_with("bp_per_bin")),
     ~ tidyr::replace_na(., 0)) %>% 
    # Reformat neutral so it is like the others
    dplyr::rename(bp_per_bin.neutral = bp_per_bin) %>% 
    # Calculate the bins percentage of each status
    dplyr::mutate(perc_gain = bp_per_bin.gain / bin_width, 
                  perc_loss = bp_per_bin.loss / bin_width, 
                  perc_neutral = bp_per_bin.neutral / bin_width) %>% 
    # Tuck away bin names as rownames before next step
    tibble::column_to_rownames("bin") %>%
    # Use these percentages for declaring final call per bin based on 
    # the perc_delta_threshold
    dplyr::mutate(
      status = dplyr::case_when(
      (perc_gain - perc_loss) > perc_delta_threshold & 
        (perc_gain - perc_neutral) > perc_delta_threshold  ~ "gain", 
            (perc_loss - perc_gain) > perc_delta_threshold & 
        (perc_loss - perc_neutral) > perc_delta_threshold  ~ "loss", 
      TRUE ~ "neutral"
    ))
}
```

## Determine NA regions of the genome

We'll determine NA regions based on what percent of that window of that region is uncallable. 
These methods are borrowed from chromosomal-instability. 

```{r}
perc_uncallable <- .75

# Find the NA region(s) for each bin without combining close regions
na_regions <- GenomicRanges::pintersect(
  IRanges::findOverlapPairs(bins, uncallable_ranges))

# Find overlap between na_regions and bin
na_overlaps <- GenomicRanges::findOverlaps(bins, na_regions)

# Get the sum of the length of all excluded regions for each bin.
excluded_length_per_bin <- tapply(
  na_regions@ranges@width, # Get length of each sequence
  na_overlaps@from, # Index of which bin it overlaps
  sum
) # Add up per bin

# Get the total bin length for each bin that has excluded regions
bin_length <- bins[unique(na_overlaps@from)]@ranges@width

# Calculate the percent overlap, adding up the na regions within a bin
pct_overlap <- excluded_length_per_bin / bin_length

# Store bins as names for sanity checking
# Note that unique and tapply put the bins in the same order
names(pct_overlap) <- unique(na_overlaps@from)

# Get the bin indices that correspond to less than the cutoff
bin_indices <- names(pct_overlap)[which(pct_overlap > perc_uncallable)]

# Call the portion bin NA
uncallable_bins <- bins[as.numeric(bin_indices)]
```

Replace these bins with 

```{r}


```


## Set up heatmap annotation objects

Extract chromosome labels and make an alternating color key for them. 

```{r}
# Extract chromosome labels
chrs <- paste0("chr", binned_counts[[1]]$chr_bin_names)

# Make chromosome labeling `HeatmapAnnotation` object.
chrs <- as.factor(chrs)

# Make a key for assigning alternating colors to the chromosomes
chr_colors <- rep(c("grey", "lightblue"), length.out = length(unique(chrs)))
names(chr_colors) <- unique(chrs)
```

Get sample names. 

```{r}
common_samples <- grep("chr_bin_names",
  colnames(binned_counts[[1]]),
  invert = TRUE,
  value = TRUE
)
```

### Set up for making heatmaps of the breakpoints

Given the `GenomicRanges` objects for each sample, create a combined plot for 
each. 

Make histology labeling `HeatmapAnnotation` object.

```{r}
# Get the histologies for the samples in this set and order them by histology
histologies <-
  data.frame(Kids_First_Biospecimen_ID = common_samples) %>%
  dplyr::inner_join(dplyr::select(metadata, Kids_First_Biospecimen_ID, short_histology)) %>%
  dplyr::mutate(short_histology = tools::toTitleCase(short_histology), 
                short_histology = as.factor(short_histology)) %>%
  dplyr::filter(!is.na(short_histology)) %>%
  dplyr::arrange(short_histology) %>%
  tibble::column_to_rownames("Kids_First_Biospecimen_ID")

#TODO: Better colors
# Get values that can be used to make colors equi distant hues away for the
# number of histology groups we have
col_val <- seq(
  from = 0, to = 1,
  length.out = length(unique(histologies$short_histology))
)

# Translate into colors
histologies_colors <- hsv(h = col_val, s = col_val, v = 1)

# Make this named based on histology
names(histologies_colors) <- unique(histologies$short_histology)
```

Make a color function. 

```{r}
col_fun <- circlize::colorRamp2(
  c(0, .25, .5, 1, 3),
  c("#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c")
)
```

```{r}
  # Drop chr bin names
  binned_counts_mat <- binned_counts_df %>%
    dplyr::select(rownames(histologies)) %>%
    t()

  # Create the Heatmap annotation object
  chr_annot <- ComplexHeatmap::HeatmapAnnotation(
    df = data.frame(chrs),
    col = list(chrs = chr_colors),
    name = "",
    show_legend = FALSE,
    show_annotation_name = FALSE
  )
  # Create the Heatmap annotation object
  hist_annot <- ComplexHeatmap::HeatmapAnnotation(
    df = data.frame(histologies),
    col = list(short_histology = histologies_colors),
    which = "row",
    show_annotation_name = FALSE
  )
  # Plot on a heatmap
  heatmap <- ComplexHeatmap::Heatmap(binned_counts_mat,
    col = col_fun,
    heatmap_legend_param = list(title = "Count of chr breaks"),
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    show_column_names = FALSE,
    show_row_names = FALSE,
    bottom_annotation = chr_annot,
    left_annotation = hist_annot,
    na_col = "#f1f1f1"
  )

```


# Session Info

```{r}
sessionInfo()
```

