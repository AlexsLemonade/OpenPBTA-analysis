---
title: "CNV GISTIC Plots"
output:   
  html_notebook: 
    toc: true
    toc_float: true
author: Candace Savonen for ALSF - CCDL
date: 2020
---

### Usage

This notebook can be run via the command line from the top directory of the 
repository as follows:

```
Rscript -e "rmarkdown::render('analyses/cnv-chrom-plot/gistic_plot.Rmd', 
                              clean = TRUE)"
```

### Set Up

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`
```

### Directories and Files

```{r}
# Path to input directory
input_dir <- file.path("..", "..", "data")
scratch_dir <- file.path("..", "..", "scratch")

# Path to output directory
plots_dir <- "plots"

# Create the plots_dir if it does not exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}
```

### Read in data 

```{r}
# Read in metadata
metadata <-
  readr::read_tsv(file.path(input_dir, "pbta-histologies.tsv"))
```

Read in and set up the seg consensus file. 

```{r}
# Read in the segment copy number data
seg_data <- data.table::fread(file.path(
  input_dir, 
  "pbta-cnv-consensus.seg.gz"),
  data.table = FALSE
) 
```

Read in the chromosomal sizes so we can fill in neutral spaces. 
(This has nothing to do with Strelka, but it just so happens this is a file with the sizes 
of the chromosomes in this genome build, hg38).

```{r}
chr_sizes <- readr::read_tsv(file.path(input_dir, "WGS.hg38.strelka2.unpadded.bed"),
  col_names = c("chrom", "start", "end")
) %>%
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom),
    levels = c(1:22, "X", "Y", "M")
  )) %>%
  # Remove sex chromosomes
  dplyr::filter(!(chrom %in% c("X", "Y", "M")))


# Make chromosome size named vector for Heatmap annotation
chr_sizes_vector <- chr_sizes$end
names(chr_sizes_vector) <- chr_sizes$chrom
```

Read in uncallable regions file. 
Regions that were not able to be accurately called will need to be color coded gray. 

```{r}
uncallable_bed <- readr::read_tsv(file.path("..", 
                                            "copy_number_consensus_call", 
                                            "ref", 
                                            "cnv_excluded_regions.bed"
                                            ),
  col_names = c("chrom", "start", "end")
) %>%
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom),
    levels = c(1:22, "X", "Y")
  )) %>%
  dplyr::filter(
    !is.na(chrom),
    # Drop sex chromosomes
    !(chrom %in% c("X", "Y", "M"))
  )
```

## Set up the seg consensus data variables

```{r}
seg_data <- seg_data %>%
  # Join the histology column to this data
  dplyr::inner_join(dplyr::select(
    metadata,
    "Kids_First_Biospecimen_ID",
    "short_histology", 
    "germline_sex_estimate", 
    "tumor_ploidy"
  ),
  by = c("ID" = "Kids_First_Biospecimen_ID")
  ) %>% 
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom), 
                               levels = c(1:22, "X", "Y"))) %>% 
  # Recode the copy number status based on ploidy
  dplyr::mutate(status = case_when(
    # when the copy number is less than inferred ploidy, mark this as a loss
    copy.num < tumor_ploidy ~ "loss",
    # if copy number is higher than ploidy, mark as a gain
    copy.num > tumor_ploidy ~ "gain",
    copy.num == tumor_ploidy ~ "neutral"
  )) %>%
  # Remove sex chromosomes
  dplyr::filter(!(chrom %in% c("X", "Y", "M")))
```

## Format each data item into GenomicRanges objects

Set up seg data as GenomicRanges. 

```{r}
seg_ranges <- GenomicRanges::GRanges(
  seqnames = seg_data$chrom,
  ranges = IRanges::IRanges(
    start = seg_data$loc.start,
    end = seg_data$loc.end
  ),
  status = seg_data$status, 
  histology = seg_data$short_histology, 
  biospecimen = seg_data$ID
)

```

Set up chromosomal data as GenomicRanges. 

```{r}
chr_ranges <- GenomicRanges::GRanges(
  seqnames = chr_sizes$chrom,
  ranges = IRanges::IRanges(
    start = chr_sizes$start,
    end = chr_sizes$end
  ),
  status = "neutral"
)
```

Set up uncallable regions as GenomicRanges. 

```{r}
uncallable_ranges <- GenomicRanges::GRanges(
  seqnames = uncallable_bed$chrom,
  ranges = IRanges::IRanges(
    start = uncallable_bed$start,
    end = uncallable_bed$end
  ), 
  status = NA
)
```

## Determine NA regions of the genome

We'll determine NA regions based on what percent of that window of that region is uncallable. 
These methods are borrowed from chromosomal-instability. 

```{r}
# Find which regions of the chromosome are uncallable
bins <- GenomicRanges::tileGenome(chr_sizes_vector, tilewidth = 1e6)
bins <- unlist(bins)
  
# Find the NA region(s) for each bin without combining close regions
na_regions <- GenomicRanges::pintersect(IRanges::findOverlapPairs(bins, uncallable_ranges))

# Find overlap between na_regions and bin
na_overlaps <- GenomicRanges::findOverlaps(bins, na_regions)

# Get the sum of the length of all excluded regions for each bin.
excluded_length_per_bin <- tapply(
  na_regions@ranges@width, # Get length of each sequence
  na_overlaps@from, # Index of which bin it overlaps
  sum
) # Add up per bin

# Get the total bin length for each bin that has excluded regions
bin_length <- bins[unique(na_overlaps@from)]@ranges@width

# Calculate the percent overlap, adding up the na regions within a bin
pct_overlap <- excluded_length_per_bin / bin_length

# Store bins as names for sanity checking
# Note that unique and tapply put the bins in the same order
names(pct_overlap) <- unique(na_overlaps@from)

# Get the bin indices that correspond to less than the cutoff
bin_indices <- names(pct_overlap)[which(pct_overlap > .75)]

# Only keep the NA regions
uncallable_binned_regions <- bins[as.numeric(bin_indices)] 

# Make a status that is already NA
uncallable_binned_regions$status <- NA
```

## Combine the data objects into one

```{r}
sample_id <- seg_ranges$biospecimen[1]

color_ranges <- function(sample_id, 
                         seg_ranges, 
                         chr_ranges, 
                         uncallable_ranges) {
  # Extract the ranges for this sample
  sample_seg_ranges <- seg_ranges[which(seg_ranges$biospecimen == sample_id)]
  
  # Put Neutral if no data and still in a chromosome
  diff_ranges <- IRanges::setdiff(chr_ranges, sample_seg_ranges)
  diff_ranges$status <- "neutral"
  
  # Combine with data
  sample_seg_ranges <- GenomicRanges::GRangesList(diff_ranges, sample_seg_ranges)
  sample_seg_ranges <- unlist(sample_seg_ranges)
  
  sample_seg_ranges$status
  
sample_seg_ranges <- GenomicRanges::pintersect(IRanges::findOverlapPairs(sample_seg_ranges,
                                                           uncallable_binned_regions))
na_indices <- GenomicRanges::findOverlaps(tmp, uncallable_binned_regions)
  
sample_seg_ranges$status[na_indices] <- NA

  uncallable_regions
  # Find overlap between na_regions and bin
  GenomicRanges::psetdiff(uncallable_regions)
}

```





## Set up heatmap annotation objects

Extract chromosome labels and make an alternating color key for them. 

```{r}
# Extract chromosome labels
chrs <- paste0("chr", binned_counts[[1]]$chr_bin_names)

# Make chromosome labeling `HeatmapAnnotation` object.
chrs <- as.factor(chrs)

# Make a key for assigning alternating colors to the chromosomes
chr_colors <- rep(c("grey", "lightblue"), length.out = length(unique(chrs)))
names(chr_colors) <- unique(chrs)
```

Get sample names. 

```{r}
common_samples <- grep("chr_bin_names",
  colnames(binned_counts[[1]]),
  invert = TRUE,
  value = TRUE
)
```

### Set up for making heatmaps of the breakpoints

Given the `GenomicRanges` objects for each sample, create a combined plot for 
each. 

Make histology labeling `HeatmapAnnotation` object.

```{r}
# Get the histologies for the samples in this set and order them by histology
histologies <-
  data.frame(Kids_First_Biospecimen_ID = common_samples) %>%
  dplyr::inner_join(dplyr::select(metadata, Kids_First_Biospecimen_ID, short_histology)) %>%
  dplyr::mutate(short_histology = tools::toTitleCase(short_histology), 
                short_histology = as.factor(short_histology)) %>%
  dplyr::filter(!is.na(short_histology)) %>%
  dplyr::arrange(short_histology) %>%
  tibble::column_to_rownames("Kids_First_Biospecimen_ID")

#TODO: Better colors
# Get values that can be used to make colors equi distant hues away for the
# number of histology groups we have
col_val <- seq(
  from = 0, to = 1,
  length.out = length(unique(histologies$short_histology))
)

# Translate into colors
histologies_colors <- hsv(h = col_val, s = col_val, v = 1)

# Make this named based on histology
names(histologies_colors) <- unique(histologies$short_histology)
```

Make a color function. 

```{r}
col_fun <- circlize::colorRamp2(
  c(0, .25, .5, 1, 3),
  c("#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c")
)
```

```{r}
  # Drop chr bin names
  binned_counts_mat <- binned_counts_df %>%
    dplyr::select(rownames(histologies)) %>%
    t()

  # Create the Heatmap annotation object
  chr_annot <- ComplexHeatmap::HeatmapAnnotation(
    df = data.frame(chrs),
    col = list(chrs = chr_colors),
    name = "",
    show_legend = FALSE,
    show_annotation_name = FALSE
  )
  # Create the Heatmap annotation object
  hist_annot <- ComplexHeatmap::HeatmapAnnotation(
    df = data.frame(histologies),
    col = list(short_histology = histologies_colors),
    which = "row",
    show_annotation_name = FALSE
  )
  # Plot on a heatmap
  heatmap <- ComplexHeatmap::Heatmap(binned_counts_mat,
    col = col_fun,
    heatmap_legend_param = list(title = "Count of chr breaks"),
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    show_column_names = FALSE,
    show_row_names = FALSE,
    bottom_annotation = chr_annot,
    left_annotation = hist_annot,
    na_col = "#f1f1f1"
  )

```


# Session Info

```{r}
sessionInfo()
```

