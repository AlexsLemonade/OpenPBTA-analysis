---
title: "CNV GISTIC Plots"
output:   
  html_notebook: 
    toc: true
    toc_float: true
author: Candace Savonen for ALSF - CCDL
date: 2020
---

### Usage

This notebook can be run via the command line from the top directory of the 
repository as follows:

```
Rscript -e "rmarkdown::render('analyses/cnv-chrom-plot/gistic_plot.Rmd', 
                              clean = TRUE)"
```

### Set Up

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`
```

### Directories and Files

```{r}
# Path to input directory
input_dir <- file.path("..", "..", "data")
scratch_dir <- file.path("..", "..", "scratch")

# Path to output directory
plots_dir <- "plots"

# Create the plots_dir if it does not exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}
```

Custom function for calculating number of base pairs of coverage for each bin. 

```{r}
bp_per_bin <- function(bin_ranges, status_ranges) {
    # Find the portions of each segment that overlap with each bin. 
    bin_overlaps <- GenomicRanges::pintersect(
      IRanges::findOverlapPairs(bin_ranges, 
                                status_ranges)
      )
  
    # Which segs are a part of which bins?
    bin_indices <- GenomicRanges::findOverlaps(bin_overlaps, 
                                                status_ranges)
  
    # Get the sum of the length of all excluded regions for each bin.
    bp_per_bin <- tapply(
      bin_overlaps@ranges@width[bin_indices@to], # Get length of each sequence
      bin_indices@from, # Index of which bin it overlaps
      sum
    ) # Add up per bin
    
    # Format as data.frame with rows = bins
    per_bin_df <- data.frame(bin = names(bp_per_bin), 
                             bp_per_bin)
    
    # Store dummy counts if there are no ranges that co
    if (nrow(per_bin_df) == 0) {
      per_bin_df <- data.frame(bin = factor(1:length(bin_ranges)), 
                               bp_per_bin = 0)
    }
    return(per_bin_df)
  }
```

```{r}
call_bin_status <- function(sample_id,
                            seg_ranges, 
                            bin_ranges = bins, 
                            perc_delta_threshold = .05) {
  message(sample_id)
  # Extract the ranges for this sample
  sample_seg_ranges <- seg_ranges[which(seg_ranges$biospecimen == sample_id)]
  
  # Split ranges into their respective statuses
  gain_ranges <- sample_seg_ranges[sample_seg_ranges$status == "gain"]
  loss_ranges <- sample_seg_ranges[sample_seg_ranges$status == "loss"]
  neutral_ranges <- sample_seg_ranges[sample_seg_ranges$status == "neutral"]

  # Calculate length of each type of status per bin
  gain_per_bin <- bp_per_bin(bin_ranges, gain_ranges)
  loss_per_bin <- bp_per_bin(bin_ranges, loss_ranges)
  neutral_per_bin <- bp_per_bin(bin_ranges, neutral_ranges)

  # Format this data into one data.frame where each row is a bin
  bin_bp_status <- data.frame(bin = factor(1:length(bin_ranges)), 
                              # Keep bin width
                              bin_width = bin_ranges@ranges@width) %>%
  # Join gains coverage data
  dplyr::left_join(gain_per_bin, 
                   by = "bin") %>% 
  # Join loss coverage data
  dplyr::left_join(loss_per_bin, 
                   by = "bin",
                   suffix = c(".gain", ".loss")) %>% 
  # Join neutral coverage data
  dplyr::left_join(neutral_per_bin, 
                   by = "bin") %>% 
  # If there is an NA, at this point we can assume it means 0
  dplyr::mutate_at(dplyr::vars(
    dplyr::starts_with("bp_per_bin")),
     ~ tidyr::replace_na(., 0)) %>% 
    # Reformat neutral so it is like the others
    dplyr::rename(bp_per_bin.neutral = bp_per_bin) %>% 
    # Calculate the bins percentage of each status
    dplyr::mutate(perc_gain = bp_per_bin.gain / bin_width, 
                  perc_loss = bp_per_bin.loss / bin_width, 
                  perc_neutral = bp_per_bin.neutral / bin_width) %>% 
    # Use these percentages for declaring final call per bin based on 
    # the perc_delta_threshold
    dplyr::mutate(
      status = dplyr::case_when(
      (perc_gain - perc_loss) > perc_delta_threshold & 
        (perc_gain - perc_neutral) > perc_delta_threshold  ~ "gain", 
            (perc_loss - perc_gain) > perc_delta_threshold & 
        (perc_loss - perc_neutral) > perc_delta_threshold  ~ "loss", 
      TRUE ~ "neutral"
    )) 
    
    # Format this data as a status
    status_df <- bin_bp_status %>% 
      dplyr::select(bin, status) %>% 
      tidyr::spread(bin, status) %>%
      dplyr::select(order(as.numeric(colnames(.))))
    
    return(status_df)
}
```

### Read in data 

```{r}
# Read in metadata
metadata <-
  readr::read_tsv(file.path(input_dir, "pbta-histologies.tsv"))
```

Read consensus seg file. 

```{r}
# Read in the segment copy number data
seg_data <- data.table::fread(file.path(
  input_dir, 
  "pbta-cnv-consensus.seg.gz"),
  data.table = FALSE
) 
```

Set up the status for each consensus segment

```{r}
seg_data <- seg_data %>%
  # Join the histology column to this data
  dplyr::inner_join(dplyr::select(
    metadata,
    "Kids_First_Biospecimen_ID",
    "short_histology", 
    "tumor_ploidy"
  ),
  by = c("ID" = "Kids_First_Biospecimen_ID")
  ) %>% 
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom), 
                               levels = c(1:22, "X", "Y"))) %>% 
  # Recode the copy number status based on ploidy
  dplyr::mutate(status = case_when(
    # when the copy number is less than inferred ploidy, mark this as a loss
    copy.num < tumor_ploidy ~ "loss",
    # if copy number is higher than ploidy, mark as a gain
    copy.num > tumor_ploidy ~ "gain",
    copy.num == tumor_ploidy ~ "neutral"
  )) %>%
  # Remove sex chromosomes
  dplyr::filter(!(chrom %in% c("X", "Y", "M")), 
                !is.na(status))
```

Set up seg data as GenomicRanges. 

```{r}
seg_ranges <- GenomicRanges::GRanges(
  seqnames = seg_data$chrom,
  ranges = IRanges::IRanges(
    start = seg_data$loc.start,
    end = seg_data$loc.end
  ),
  status = seg_data$status, 
  histology = seg_data$short_histology, 
  biospecimen = seg_data$ID
)

```

Read in the chromosomal sizes for making bins. 
(This has nothing to do with Strelka, but it just so happens this is a file with the sizes 
of the chromosomes in this genome build, hg38).

```{r}
chr_sizes <- readr::read_tsv(file.path(input_dir, "WGS.hg38.strelka2.unpadded.bed"),
  col_names = c("chrom", "start", "end")
) %>%
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom),
    levels = c(1:22, "X", "Y", "M")
  )) %>%
  # Remove sex chromosomes
  dplyr::filter(!(chrom %in% c("X", "Y", "M")))


# Make chromosome size named vector for Heatmap annotation
chr_sizes_vector <- chr_sizes$end
names(chr_sizes_vector) <- chr_sizes$chrom
```

Read in uncallable regions file. 
Regions that were not able to be accurately called will need to be color coded gray. 

```{r}
uncallable_bed <- readr::read_tsv(
  file.path("..", 
            "copy_number_consensus_call", 
            "ref", 
            "cnv_excluded_regions.bed"),
  col_names = c("chrom", "start", "end")
) %>%
  # Reformat the chromosome variable to drop the "chr"
  dplyr::mutate(chrom = factor(gsub("chr", "", chrom),
    levels = c(1:22, "X", "Y")
  )) %>%
  dplyr::filter(
    !is.na(chrom),
    # Drop sex chromosomes
    !(chrom %in% c("X", "Y", "M"))
  )
```

Set up uncallable regions as GenomicRanges. 

```{r}
uncallable_ranges <- GenomicRanges::GRanges(
  seqnames = uncallable_bed$chrom,
  ranges = IRanges::IRanges(
    start = uncallable_bed$start,
    end = uncallable_bed$end
  )
)
```

## Call bin CN statuses for each sample

```{r}
# Find which regions of the chromosome are uncallable
bins <- GenomicRanges::tileGenome(chr_sizes_vector, 
                                  tilewidth = 1e6)
bins <- unlist(bins)
```

```{r}
sample_ids <- unique(seg_data$ID)

bin_calls_list <- lapply(sample_ids, 
       call_bin_status, 
       bin_ranges = bins, 
       seg_ranges = seg_ranges, 
       perc_delta_threshold = 0.05)

# Bring along sample IDs
names(bin_calls_list) <- sample_ids

# Format into data.frame
bin_calls_df <- dplyr::bind_rows(bin_calls_list, 
                                 .id = "biospecimen_id")
```

## Determine NA regions of the genome

We'll determine NA regions based on what percent of that window of that region is uncallable. 
These methods are borrowed from chromosomal-instability. 

```{r}
perc_uncallable <- .75

# Find the NA region(s) for each bin without combining close regions
na_regions <- GenomicRanges::pintersect(
  IRanges::findOverlapPairs(bins, uncallable_ranges))

# Find overlap between na_regions and bin
na_overlaps <- GenomicRanges::findOverlaps(bins, na_regions)

# Get the sum of the length of all excluded regions for each bin.
excluded_length_per_bin <- tapply(
  na_regions@ranges@width, # Get length of each sequence
  na_overlaps@from, # Index of which bin it overlaps
  sum
) # Add up per bin

# Get the total bin length for each bin that has excluded regions
bin_length <- bins[unique(na_overlaps@from)]@ranges@width

# Calculate the percent overlap, adding up the na regions within a bin
pct_overlap <- excluded_length_per_bin / bin_length

# Store bins as names for sanity checking
# Note that unique and tapply put the bins in the same order
names(pct_overlap) <- unique(na_overlaps@from)

# Get the bin indices that correspond to less than the cutoff
bin_indices <- names(pct_overlap)[which(pct_overlap > perc_uncallable)]
```

Replace these bins with NAs.

```{r}
bin_calls_df[, bin_indices] <- NA
```

## Set up heatmap annotation objects

Make color key. 

```{r}
color_key <- structure(c("#f4a582", "#0571b0", "#ca0020"), 
                       names = unique(bin_calls_df$status)) 
```

### Make column annotation object

Extract chromosome labels and make an alternating color key for them. 

```{r}
# Set up chromosome labels from bins as a factor vector
chrs <- paste0("chr", decode(bins@seqnames))
chrs <- as.factor(chrs)

# Make a key for assigning alternating colors to the chromosomes
chr_colors <- rep(c("grey", "lightblue"), length.out = length(unique(chrs)))
names(chr_colors) <- unique(chrs)
```

Make chromosomal labeling `HeatmapAnnotation` object.

```{r}
# Create the Heatmap annotation object
chr_annot <- ComplexHeatmap::HeatmapAnnotation(
  df = data.frame(chrs),
  col = list(chrs = chr_colors),
  name = "",
  show_legend = FALSE,
  show_annotation_name = FALSE
)
```

### Make row annotation object

Make histology labeling `HeatmapAnnotation` object.

```{r}
# Get the histologies for the samples in this set and order them by histology
histologies <-
  data.frame(Kids_First_Biospecimen_ID = rownames(bin_calls_df)) %>%
  # Join samples of this dataset to the metadata we need
  dplyr::inner_join(metadata %>%
    dplyr::select(Kids_First_Biospecimen_ID, short_histology)) %>%
  dplyr::mutate(
    # Make the terms more uniform in their capitalization
    short_histology = tools::toTitleCase(short_histology),
    short_histology = as.factor(short_histology)
  ) %>%
  # Remove samples that don't have histology
  dplyr::filter(!is.na(short_histology)) %>%
  dplyr::arrange(short_histology) %>%
  # ComplexHeatmap matches using rownames
  tibble::column_to_rownames("Kids_First_Biospecimen_ID")
```

Set up histology color key. 

```{r}
# TODO: Better colors
# Get values that can be used to make colors equi distant hues away for the
# number of histology groups we have
col_val <- seq(
  from = 0, to = 1,
  length.out = length(unique(histologies$short_histology))
)

# Translate into colors
histologies_colors <- hsv(h = col_val, s = col_val, v = 1)

# Make this named based on histology
names(histologies_colors) <- unique(histologies$short_histology)
```

```{r}
# Create the Heatmap annotation object
hist_annot <- ComplexHeatmap::HeatmapAnnotation(
  df = data.frame(histologies),
  col = list(short_histology = histologies_colors),
  which = "row",
  show_annotation_name = FALSE
)
```

## Assemble heatmap

```{r}
# Plot on a heatmap
heatmap <- ComplexHeatmap::Heatmap(as.matrix(status_df),
  heatmap_legend_param = list(title = "CN status"),
  col = color_key,
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  show_column_names = FALSE,
  show_row_names = FALSE,
  bottom_annotation = arm_annot,
  left_annotation = hist_annot,
  na_col = "#f7f7f7"
)
```

## Print out heatmap

```{r}
heatmap
```


```{r}
# Save plot as PDF
pdf(file.path(plots_dir, "cn_status_heatmap.pdf"))
heatmap
dev.off()
```

# Session Info

```{r}
sessionInfo()
```


