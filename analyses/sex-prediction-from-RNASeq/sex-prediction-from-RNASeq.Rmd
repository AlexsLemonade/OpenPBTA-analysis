---
title: "R Notebook"
title: "Sex Prediction from RNA-Seq"
author: Bill Amadio
date: 2019
---

Libraries and parameters used in this run.  Change values as needed for future runs.

```{r}
library(stats)
library(glmnet)
library(glmnetUtils)

#transcripts whose median absolute deviations are below mad_threshold will be dropped
#set mad_threshold here with a value >= 0 and <= 1.
mad_threshold <- 0.75

# A percentage of samples will be held out to test predictive accuracy after model is developed
# Set train percent is the percentage used to build the model; 1 - train_percent is the holdout percentage
# Set train_percent with a value >= 0 and <= 1
train_percent <- 0.70

#This is the seed used to randomly partition the data set into train and test
train_test_seed <- 36354

# gene expression data is in either pbta-gene-expression-kallisto.stranded.rds or
# pbta-gene-expression-kallisto.polya.rds.  Set the desired path here.

gene_expression_file_path <- "../../data/pbta-gene-expression-kallisto.stranded.rds"


# histologies data is in pbta-histologies.tsv
# Set the desired path here.

histologies_file_path <- "../../data/pbta-histologies.tsv"
```


Read gene expression data.

```{r}

ge <- readRDS(gene_expression_file_path)


```

Metadata is histologies_file_path.  reported_gender is our target variable. Kids_First_Biospecimen_ID is the unique identifier for each sample. 

```{r}
histologies <- read.delim(histologies_file_path, header=TRUE, sep="\t", stringsAsFactors = FALSE)

valid_reported_gender_samples <- histologies[which(histologies[, "reported_gender"] == "Female" | histologies[, "reported_gender"] == "Male"), "Kids_First_Biospecimen_ID"]

```


Let's try a model with the top (1 - mad_threshold) highest mads.

Set colnames(df) to transcript IDs.
Set rownames(df) to sample names.

```{r}
# dropping the gene and transcript identifiers and creating a matrix
gene_expression_mat <- as.matrix(ge[, -c(1,2)])
rownames(gene_expression_mat) <- ge[, 1]

#calculate median absolute deviation for each transcript
tx_mads <- apply(gene_expression_mat, 1, function(x) mad(x, high=TRUE))

#df is the transpose of gene_expression_mat reduced to the top mad transcripts
#top is defined by 1 - mad_threshold
df <- t(gene_expression_mat[which(tx_mads >= quantile(tx_mads, mad_threshold)), ])
```


Keep only rows of df corresponding to samples with reported_gender Female or Male.
```{r}

df <- df[rownames(df) %in% valid_reported_gender_samples, ]

```

Use reported_gender column from histologies as the response.

Extract reported_gender values from reported_gender column of histologies.  Put these value in a two-column dataframe
  c("Kids_First_Biospecimen_ID", "reported_gender").

```{r}

reported_gender <- histologies[histologies$Kids_First_Biospecimen_ID %in% rownames(df), c("Kids_First_Biospecimen_ID", "reported_gender")]

```

Check sequence of rownames(df) and reported_gender[, 1].  reported_gender_response holds the reported_gender values in the same Kids_First_Biospecimen_ID sequence as rownames(df).

```{r}

match_index <- unlist(sapply(rownames(df), function(x) which(reported_gender[, 1] == x)))

reported_gender_response <- reported_gender[match_index, 2]
```


Build predictive model for reported_gender_response.
Hold out a percentage of the samples to test accuracy after cross-validation tuning of 
  lambda and alpha regularization parameters.

```{r}

set.seed(train_test_seed)
train_set <- sample(1:nrow(df), floor(train_percent*nrow(df)))
test_set <- setdiff(1:nrow(df), train_set)

ptm <- proc.time()
sex.cva <- cva.glmnet(df[train_set, ], reported_gender_response[train_set], standardize=TRUE, 
                      alpha = seq(0, 1, len = 11)^3, family="binomial")
proc.time() - ptm
```

Plot Deviance vs. log(lambda), one curve for each value of alpha.

```{r}
plot(sex.cva)
```

Plot CVloss against alpha.

```{r}
minlossplot(sex.cva, cv.type="min")
```

Although Hastie recommends against looking into the cva object, I could not retrieve optimal
  values of lambda and alpha through code without doing so.

the cva object contains a list, called modlist, of 11 objects, one for each of the alpha values tested.
The CVloss plotted above is the minimum cvm value for each of the 11 objects in cva$modlist.
The alpha corresponding to the minimum of these minimum cvm values is optimal.

```{r}
best_cvm_values <- sapply(sex.cva$modlist, function(x) min(x$cvm))
best_alpha_index <- which(best_cvm_values == min(best_cvm_values))

# look at sex.cva$alpha[best_alpha_index] to find the tuned value of alpha

```

The cva.modlist object corresponds to a given alpha value, and contains results for all the lambda values 
  tested for the corresponding alpha value.

The best performing lambda value is stored within the modlist object as lambda.min.

We carry forward the predictors with non-zero coefficients in the optimal (minimum CVloss) model.

```{r}
best_fit <- sex.cva$modlist[[best_alpha_index]]

#look at best_fit$lambda.min to find best lambda corresponding to tuned alpha

non_zero_features <- which(coef(best_fit, s = best_fit$lambda.min) != 0)

```

Store the non-zero coefficients


```{r}

non_zero_coefs <- coef(best_fit, s=best_fit$lambda.min)[non_zero_features]

```

Store the non-zero transcript IDs

```{r}
non_zero_transcripts <-  colnames(df)[non_zero_features]
```

Determine model accuracy on the holdout sample.

```{r}
p <- predict(best_fit, newx = df[test_set, ], type = "class", s = best_fit$lambda.min)
test_accuracy <- length(which(p == reported_gender_response[test_set]))/length(p)
# look at which(p == reported_gender_response[test_set]) for successful calls
# look at which(p != reported_gender_response[test_set]) for unsuccessful calls
```

