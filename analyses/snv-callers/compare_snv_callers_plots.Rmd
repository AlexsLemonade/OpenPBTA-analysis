---
title: "Plot Caller Comparisons"
output: 
  html_notebook:
    toc: TRUE
    toc_float: TRUE
author: C. Savonen for ALSF CCDL
date: 2019
---

Purpose: After creating a consensus file with `02-merge_callers.R`, this notebook 
plots these data in a series of plots to compare the consensus calls to the individual 
callers. 

*Notable Findings:*  

- [VarDict calls more mutations](#upset-graph) than any of the other callers. 
Many of these have [very low ](#vaf-distributions) suggesting that some may be sequencing errors. 

- Mutect2, Strelka2, and Lancet do have [plenty of mutations in common](#upset-graph). 

### Outline of analyses completed:
- [Consensus numbers](#get-consensus-numbers)
- [Upset graph](#upset-graph)  
- [VAF of combinations of callers](#vaf-for-combination-sets-of-callers)
- [Base changes by caller](#base-changes)
- [VAF distributions by caller](#vaf-distributions)
- [VAF correlations between callers](#vaf-correlations)

#### Usage

To run this from the command line, use:
```
Rscript -e "rmarkdown::render('analyses/snv-callers/compare_snv_callers_plots.Rmd', 
                              clean = TRUE)"
```

_This assumes you are in the top directory of the repository._

## Setup

#### Packages and functions

Read in set up script.

```{r}
# Magrittr pipe
`%>%` <- dplyr::`%>%`
```

Set up directories. 

```{r}
scratch_dir <- file.path("..", "..", "scratch")
results_dir <- file.path("results", "pbta-comparison")
plots_dir <- file.path("plots", "pbta-comparison")

if (!dir.exists(results_dir)) {
  dir.create(results_dir)
}
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir)
}
```

```{r}
upset_plot <- function(callers_per_mutation_df) {
callers_per_mutation_df %>% 
  dplyr::group_by(caller_combo) %>%
  dplyr::tally() %>% 
  ggplot2::ggplot(ggplot2::aes(x = reorder(caller_combo, -n), y = n)) +
  ggplot2::geom_bar(position = "dodge", stat = "identity") +
  ggplot2::geom_text(ggplot2::aes(label = n), 
                     position = ggplot2::position_dodge(width = 0.9), angle = 45, 
                     hjust = -0.1, 
                     vjust = -0.1) +
  ggplot2::theme_classic() +
  ggupset::scale_x_mergelist(sep = "-") +
  ggupset::axis_combmatrix(sep = "-") +
  ggplot2::xlab("") +
  ggplot2::ylab("") 
}
```

## Connect to database

Connect to SQLite database.

```{r}
# Start up connection
con <- DBI::dbConnect(RSQLite::SQLite(), 
                      file.path(scratch_dir, "testing_snv_db.sqlite"))
```

Note what columns we will join by.

```{r}
join_cols = c("Chromosome",
              "Start_Position",
              "Reference_Allele",
              "Allele",
              "Tumor_Sample_Barcode", 
              "Variant_Classification")
```

Set up tables from the database but only call the columns we need.

```{r}
strelka <- dplyr::tbl(con, "strelka") %>% 
  dplyr::select(join_cols, "VAF")

lancet <- dplyr::tbl(con, "lancet") %>% 
  dplyr::select(join_cols, "VAF")

mutect <- dplyr::tbl(con, "mutect") %>% 
  dplyr::select(join_cols, "VAF")

vardict <- dplyr::tbl(con, "vardict") %>% 
  dplyr::select(join_cols, "VAF")
```

Because `DBI` does not support full_join, we had to use a series of `left_join` and
`union_all` calls in order to get a full join of all the callers. 

```{r}
# This script will do the full join of the data for us
source(file.path("util", "full_join_callers.R"))

# Bring out the data.frame
all_caller_df <- all_caller %>%
  as.data.frame() 

# Take a peek at what this looks like
head(all_caller_df)
```

## Get consensus numbers

Make a data.frame with only the VAFs and turn into detected or not. 

```{r}
detect_df <- all_caller_df %>% 
 # Bring over VAF columns
 dplyr::select(dplyr::starts_with("VAF_")) %>% 
 # Turn into detected or not
 dplyr::transmute_all(is.na) %>% 
 # Make row  ids for tracking purposes
 tibble::rowid_to_column("index")
```

Count up how many callers call each mutation but ignore VarDict. 

```{r}
consensus_count <- detect_df %>%
  # Ignore VarDict and index
  dplyr::select(-VAF_vardict, -index) %>%
  # Get the number of callers that call each mutation
  dplyr::mutate(num = rowSums(.)) %>% 
  # Bring back the index (again)
  tibble::rowid_to_column("index") %>%
  # Filter out the ones that were there because of VarDict
  dplyr::filter(num != 0)
```

Print out the numbers for the three callers' consensus.

```{r}
cat(" At least 1 out of 3:", nrow(consensus_count), "\n",
    "At least 2 out of 3:", sum(consensus_count$num >= 2), "\n",
    "3 out of 3:", sum(consensus_count$num == 3))
```

Create consensus VAF based on strelka's VAFs and which mutations would be included

```{r}
# Make new VAF column based on strelka's VAFs
all_caller_df$VAF_consensus <- all_caller_df$VAF_strelka

# Figure out which mutations are not in the consensus
not_consensus <- consensus_count$index[which(consensus_count$num < 3)]

# Make non consensus mutations in consensus)VAF an NA
all_caller_df$VAF_consensus[not_consensus] <- NA
```

Make a long form VAF data.frame for exploring mutations VAFs from each caller. 

```{r}
vaf_df <- all_caller_df %>% 
  dplyr::select(dplyr::starts_with("VAF_"), Variant_Classification) %>%
  # Make ids so we can keep track of 
  tibble::rowid_to_column("index") %>%
  # Make long format
  tidyr::gather(key = "caller", value = "vaf", -index, -Variant_Classification) %>% 
  # Drop the `VAF_`
  dplyr::mutate(caller = gsub("VAF_", "", caller)) %>% 
  dplyr::filter(!is.na(vaf))
```

Get median vaf for each mutation with each caller combination. 

```{r}
# Take out the consensus VAF for this combination
median_vaf_df <- vaf_df %>% 
  dplyr::filter(caller != "consensus")

vaf_med <- tapply(
    median_vaf_df$vaf,
    median_vaf_df$index,
    median
  ) %>% 
  as.data.frame() %>%
  tibble::rownames_to_column("index")
```

```{r}
# Join the median VAF and the callers that call that mutation into one data.frame
callers_per_mutation <- callers_per_mutation %>%
  dplyr::inner_join(vaf_med, by = "index") %>%
  dplyr::mutate(index = as.integer(index)) %>%
  dplyr::left_join(long_caller_df %>% 
                      dplyr::select(Variant_Classification, index), 
                   by = "index") %>%
  # Make column names more sensible
  dplyr::rename(caller_combo = "..x", median_vaf = "..y") 
```

Make a list that UpsetR can use to find overlap. 

```{r}
callers_per_mutation <- list(
  lancet = which(detect_df$VAF_lancet),
  mutect = which(detect_df$VAF_mutect),
  strelka = which(detect_df$VAF_strelka), 
  vardict = which(detect_df$VAF_vardict)
  )
```

## Upset graph

Make the upset plot. 

```{r}
UpSetR::upset(UpSetR::fromList(callers_per_mutation), order.by = "freq")
```

Save this plot to a png

```{r}
# We can save the plot like a normal ggplot
ggplot2::ggsave(plot = upsettr_plot, 
                file.path(plots_dir, "pbta-upset_plot.png"))
```

Transcripts only upset plot. 

```{r}
callers_per_mutation %>% 
  dplyr::filter(!(Variant_Classification %in% c("5'Flank", "3'Flank", "IGR", "Intron"))) %>%
  upset_plot() + 
  ggplot2::ylim(c(0, 400000)) # So the label shows up
```

Non transcript upset plot. 

```{r}
callers_per_mutation %>% 
  dplyr::filter(Variant_Classification %in% c("5'Flank", "3'Flank", "IGR", "Intron")) %>%
  upset_plot() +
  ggplot2::ylim(c(0, 7e+6))
```

## VAF for combination sets of callers

Graph mutations by combinations of callers and plot the VAF density.
Get list of callers per mutation and the median vaf for each. 
Graph the median VAF for each combination of callers.

```{r}
# Make this plot
median_vaf_plot <- callers_per_mutation %>%
  ggplot2::ggplot(ggplot2::aes(x = caller_combo, y = median_vaf)) +
  ggplot2::geom_violin() +
  ggplot2::theme_classic() +
  ggupset::scale_x_mergelist(sep = "-") +
  ggupset::axis_combmatrix(sep = "-") +
  ggplot2::xlab("") +
  ggplot2::ylab("Median VAF Across Callers")

# Print out
median_vaf_plot
```

```{r}
# Save this plot
ggplot2::ggsave(plot = median_vaf_plot, 
                file.path(plots_dir, "upset_median_vaf_plot.png"))
```

## Base Changes 

Summarize base change information per caller. 

```{r}
# Summarize by the number of times each base change shows up in each category.
perc_change_df <- all_caller_df %>% 
  # Make change variable
  dplyr::mutate(base_change = paste0(Allele, ">", Reference_Allele)) %>% 
  dplyr::mutate(
    # From the base_change variable, summarize insertions, deletions, and
    # changes that are more than one base into their own groups.
    change = dplyr::case_when(
      grepl("^-", base_change) ~ "ins",
      grepl("-$", base_change) ~ "del",
      nchar(base_change) > 3 ~ "long_change",
      TRUE ~ base_change
    )
  ) %>%
  # Whittle down to necessary columns
  dplyr::select(change, dplyr::starts_with("VAF_")) %>% 
  # Make this long form
  tidyr::gather(key = "caller", value = "vaf", -change) %>% 
  # Drop the prefix
  dplyr::mutate(caller = gsub("VAF_", "", caller)) %>% 
  # Get rid of NA rows
  dplyr::filter(!is.na(vaf)) %>%
  # Summarize the number of mutations per caller
  dplyr::count(caller, change, name = "count") %>%
  dplyr::add_count(caller, wt = count) %>%
  # Calculate the percent of each 
  dplyr::mutate(percent = count / n) %>%
  # Drop nonsensical change
  dplyr::filter(!grepl("N>*|*>N|C>C|T>T|A>A|G>G", change), 
                !is.na(change)) %>%
  dplyr::mutate(
    change = as.factor(change),
    # Change factor level order so ins and del are at the end
    change = forcats::fct_relevel(change, "ins", "del", "long_change", after = Inf)
  ) 
```

Make a barplot illustrating the percent of the mutations for each caller that 
that are each type of change. 

```{r}
perc_change_df %>%
  ggplot2::ggplot(ggplot2::aes(x = change, y = percent)) +
  ggplot2::theme_classic() +
  ggplot2::geom_bar(
    position = "dodge", stat = "identity",
    ggplot2::aes(fill = caller)
  ) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
  ggplot2::xlab("") +
  ggplot2::ylab("Percent of callers' mutations") +
  colorblindr::scale_fill_OkabeIto()
```

```{r}
# Save this plot
ggplot2::ggsave(file.path(plots_dir, "perc_base_change_plot.png"))
```

## VAF distributions

Make a violin plot of each caller. 

```{r}
long_vaf_df %>%
  ggplot2::ggplot(ggplot2::aes(x = caller, y = vaf, color = caller)) +
  ggplot2::geom_violin() +
  ggplot2::theme_classic() +
  colorblindr::scale_color_OkabeIto()
```

```{r}
# Save this plot
ggplot2::ggsave(file.path(plots_dir, "vaf_violin_plot.png"))
```

## VAF correlations

Correlate VAF's across callers

```{r}
vaf_df %>% 
  dplyr::select(-VAF_consensus, -Variant_Classification) %>% 
  cor() %>% 
  knitr::kable()
``` 

## Mutation Region barplot

Summarize `Variant_Classification` information per caller. 

```{r}
# Summarize by the number of times each base change shows up in each category.
perc_var_df <- long_vaf_df %>% 
  # Summarize the number of mutations per caller
  dplyr::count(caller, Variant_Classification, name = "count") %>%
  dplyr::add_count(caller, wt = count) %>%
  # Calculate the percent of each 
  dplyr::mutate(percent = count / n)
```

Make a barplot illustrating the percent of the mutations for each caller that 
that are each type of change. 

```{r}
perc_var_df %>%
  ggplot2::ggplot(ggplot2::aes(x = caller, y = percent)) +
  ggplot2::theme_classic() +
  ggplot2::geom_bar(
    position = "stack", stat = "identity",
    ggplot2::aes(fill = Variant_Classification)
  ) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
  ggplot2::xlab("") +
  ggplot2::ylab("Percent of callers' mutations")
```

```{r}
# Save this plot
ggplot2::ggsave(file.path(plots_dir, "variant_classification_plot.png"))
```

## Session Info

```{r}
sessionInfo()
```
